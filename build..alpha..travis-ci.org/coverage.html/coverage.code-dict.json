{"/home/travis/build/npmtest/node-npmtest-emailjs/test.js":"/* istanbul instrument in package npmtest_emailjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-emailjs/lib.npmtest_emailjs.js":"/* istanbul instrument in package npmtest_emailjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_emailjs = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_emailjs = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-emailjs/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-emailjs && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_emailjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_emailjs\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_emailjs.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_emailjs.rollup.js'] =\n            local.assetsDict['/assets.npmtest_emailjs.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_emailjs.__dirname + '/lib.npmtest_emailjs.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-emailjs/node_modules/emailjs/email.js":"exports.server = require('./smtp/client');\nexports.message = require('./smtp/message');\nexports.SMTP = require('./smtp/smtp');\n","/home/travis/build/npmtest/node-npmtest-emailjs/node_modules/emailjs/smtp/client.js":"var smtp       = require('./smtp');\nvar smtpError    = require('./error');\nvar message      = require('./message');\nvar addressparser= require('addressparser');\n\nvar Client = function(server)\n{\n   this.smtp         = new smtp.SMTP(server);\n   //this.smtp.debug(1);\n\n   this.queue        = [];\n   this.timer        = null;\n   this.sending      = false;\n   this.ready        = false;\n};\n\nClient.prototype = \n{\n   _poll: function()\n   {\n      var self = this;\n\n      clearTimeout(self.timer);\n\n      if(self.queue.length)\n      {\n         if(self.smtp.state() == smtp.state.NOTCONNECTED)\n            self._connect(self.queue[0]);\n\n         else if(self.smtp.state() == smtp.state.CONNECTED && !self.sending && self.ready)\n            self._sendmail(self.queue.shift());\n      }\n      // wait around 1 seconds in case something does come in, otherwise close out SMTP connection if still open\n      else if(self.smtp.state() == smtp.state.CONNECTED)\n         self.timer = setTimeout(function() { self.smtp.quit(); }, 1000);\n   },\n\n   _connect: function(stack)\n   {\n      var self = this,\n\n      connect = function(err)\n      {\n         if(!err)\n         {\n            var begin = function(err)\n            {\n               if(!err)\n               {\n                  self.ready = true;\n                  self._poll();\n               }\n               else {\n                  stack.callback(err, stack.message);\n\n                  // clear out the queue so all callbacks can be called with the same error message\n                  self.queue.shift();\n                  self._poll();\n               }\n            };\n\n            if(!self.smtp.authorized())\n               self.smtp.login(begin);\n\n            else\n               self.smtp.ehlo_or_helo_if_needed(begin);\n         }\n         else {\n            stack.callback(err, stack.message);\n\n            // clear out the queue so all callbacks can be called with the same error message\n            self.queue.shift();\n            self._poll();\n         }\n      };\n\n      self.ready = false;\n      self.smtp.connect(connect);\n   },\n\n   send: function(msg, callback)\n   {\n      var self = this;\n\n      if(!(msg instanceof message.Message) \n          && msg.from \n          && (msg.to || msg.cc || msg.bcc)\n          && (msg.text || this._containsInlinedHtml(msg.attachment)))\n         msg = message.create(msg);\n\n      if(msg instanceof message.Message)\n      {\n         msg.valid(function(valid, why)\n         {\n            if(valid)\n            {\n               var stack = \n               {\n                  message:    msg,\n                  to:         addressparser(msg.header.to),\n                  from:       addressparser(msg.header.from)[0].address,\n                  callback:   callback || function() {}\n               };\n\n               if(msg.header.cc)\n                  stack.to = stack.to.concat(addressparser(msg.header.cc));\n\n               if(msg.header.bcc)\n                  stack.to = stack.to.concat(addressparser(msg.header.bcc));\n\n               if(msg.header['return-path'] && addressparser(msg.header['return-path']).length)\n                 stack.returnPath = addressparser(msg.header['return-path'])[0].address;\n\n               self.queue.push(stack);\n               self._poll();\n            }\n            else\n               callback(new Error(why), msg);\n         });\n      }\n      else\n         callback(new Error(\"message is not a valid Message instance\"), msg);\n   },\n\n   _containsInlinedHtml: function(attachment) {\n\t   if (Array.isArray(attachment)) {\n\t\t   return attachment.some((function(ctx) {\n\t\t\t   return function(att) {\n\t\t\t\t   return ctx._isAttachmentInlinedHtml(att);\n\t\t\t   };\n\t\t   })(this));\n\t   } else {\n\t\t   return this._isAttachmentInlinedHtml(attachment);\n\t   }   \n\t},\n\n   _isAttachmentInlinedHtml: function(attachment) {\n\t   return attachment && \n\t\t  (attachment.data || attachment.path) && \n\t\t   attachment.alternative === true;\n   },\n\n   _sendsmtp: function(stack, next)\n   {\n      var self   = this;\n      var check= function(err)\n      {\n         if(!err && next)\n         {\n            next.apply(self, [stack]);\n         }\n         else\n         {\n            // if we snag on SMTP commands, call done, passing the error\n            // but first reset SMTP state so queue can continue polling\n            self.smtp.rset(function() { self._senddone(err, stack); });\n         }\n      };\n\n      return check;\n   },\n\n   _sendmail: function(stack)\n   {\n      var self = this;\n      var from = stack.returnPath || stack.from;\n      self.sending = true;\n      self.smtp.mail(self._sendsmtp(stack, self._sendrcpt), '<' + from + '>');\n   },\n\n   _sendrcpt: function(stack)\n   {\n      var self = this, to = stack.to.shift().address;\n      self.smtp.rcpt(self._sendsmtp(stack, stack.to.length ? self._sendrcpt : self._senddata), '<'+ to +'>');\n   },\n\n   _senddata: function(stack)\n   {\n      var self = this;\n      self.smtp.data(self._sendsmtp(stack, self._sendmessage));\n   },\n\n   _sendmessage: function(stack)\n   {\n      var self = this, stream = stack.message.stream();\n\n      stream.on('data', function(data) { self.smtp.message(data); });\n      stream.on('end', function() { self.smtp.data_end(self._sendsmtp(stack, function() { self._senddone(null, stack) })); });\n\n      // there is no way to cancel a message while in the DATA portion, so we have to close the socket to prevent\n      // a bad email from going out\n      stream.on('error', function(err) { self.smtp.close(); self._senddone(err, stack); });\n   },\n\n   _senddone: function(err, stack)\n   {\n      var self = this;\n      self.sending = false;\n      stack.callback(err, stack.message);\n      self._poll();\n   }\n};\n\nexports.Client = Client;\n\nexports.connect = function(server)\n{\n   return new Client(server);\n};\n","/home/travis/build/npmtest/node-npmtest-emailjs/node_modules/emailjs/smtp/smtp.js":"/*\n * SMTP class written using python's (2.7) smtplib.py as a base\n */\nvar net = require('net');\nvar crypto = require('crypto');\nvar os = require('os');\nvar tls = require('tls');\nvar util = require('util');\nvar events = require('events');\n\nvar SMTPResponse = require('./response');\nvar SMTPError = require('./error');\n\nvar SMTP_PORT = 25;\nvar SMTP_SSL_PORT = 465;\nvar SMTP_TLS_PORT = 587;\nvar CRLF = \"\\r\\n\";\nvar AUTH_METHODS = {\n  PLAIN: 'PLAIN',\n  CRAM_MD5: 'CRAM-MD5',\n  LOGIN: 'LOGIN',\n  XOAUTH2: 'XOAUTH2'\n};\nvar TIMEOUT = 5000;\nvar DEBUG = 0;\n\nvar log = function() {\n  if (DEBUG) {\n    Array.prototype.slice.call(arguments).forEach(function(d) {\n      console.log(d);\n    });\n  }\n};\n\nvar quotedata = function(data) {\n  // Quote data for email.\n  // Double leading '.', and change Unix newline '\\\\n', or Mac '\\\\r' into\n  // Internet CRLF end-of-line.\n\n  return data.replace(/(?:\\r\\n|\\n|\\r(?!\\n))/g, CRLF).replace(/^\\./gm, '..');\n};\n\nvar caller = function(callback) {\n  if (typeof(callback) == 'function') {\n    var args = Array.prototype.slice.call(arguments);\n    args.shift();\n\n    callback.apply(null, args);\n  }\n};\n\nvar SMTPState = {\n  NOTCONNECTED: 0,\n  CONNECTING: 1,\n  CONNECTED: 2\n};\n\nvar SMTP = function(options) {\n  events.EventEmitter.call(this);\n\n  options = options || {};\n\n  this.sock = null;\n  this.timeout = options.timeout || TIMEOUT;\n  this.features = null;\n  this._state = SMTPState.NOTCONNECTED;\n  this._secure = false;\n  this.loggedin = (options.user && options.password) ? false : true;\n  this.domain = options.domain || os.hostname();\n  this.host = options.host || 'localhost';\n  this.port = options.port || (options.ssl ? SMTP_SSL_PORT : options.tls ? SMTP_TLS_PORT : SMTP_PORT);\n  this.ssl = options.ssl || false;\n  this.tls = options.tls || false;\n  this.monitor = null;\n  this.authentication = options.authentication || [AUTH_METHODS.CRAM_MD5, AUTH_METHODS.LOGIN, AUTH_METHODS.PLAIN, AUTH_METHODS.XOAUTH2];\n\n  // keep these strings hidden when quicky debugging/logging\n  this.user = function() {\n    return options.user;\n  };\n  this.password = function() {\n    return options.password;\n  };\n};\n\nSMTP.prototype = {\n  debug: function(level) {\n    DEBUG = level;\n  },\n\n  state: function() {\n    return this._state;\n  },\n\n  authorized: function() {\n    return this.loggedin;\n  },\n\n  connect: function(callback, port, host, options) {\n    options = options || {};\n\n    var self = this;\n\n    self.host = host || self.host;\n    self.port = port || self.port;\n    self.ssl = options.ssl || self.ssl;\n\n    if (self._state != SMTPState.NOTCONNECTED) {\n      self.quit(function() {\n        self.connect(callback, port, host, options);\n      });\n      return;\n    }\n\n    var connected = function(err) {\n      if (!err) {\n        log(\"connected: \" + self.host + \":\" + self.port);\n\n        if (self.ssl && !self.tls) {\n          // if key/ca/cert was passed in, check if connection is authorized\n          if (typeof(self.ssl) != 'boolean' && !self.sock.authorized) {\n            self.close(true);\n            caller(callback, SMTPError('could not establish an ssl connection', SMTPError.CONNECTIONAUTH, err));\n          } else self._secure = true;\n        }\n      } else {\n        self.close(true);\n        caller(callback, SMTPError(\"could not connect\", SMTPError.COULDNOTCONNECT, err));\n      }\n    };\n\n    var response = function(err, msg) {\n      if (err) {\n        if (self._state === SMTPState.NOTCONNECTED && !self.sock) {\n          return;\n        }\n        self.close(true);\n        caller(callback, err);\n      } else if (msg.code == '220') {\n        log(msg.data);\n\n        // might happen first, so no need to wait on connected()\n        self._state = SMTPState.CONNECTED;\n        caller(callback, null, msg.data);\n      } else {\n        log(\"response (data): \" + msg.data);\n        self.quit(function() {\n          caller(callback, SMTPError(\"bad response on connection\", SMTPError.BADRESPONSE, err, msg.data));\n        });\n      }\n    };\n\n    self._state = SMTPState.CONNECTING;\n    log(\"connecting: \" + self.host + \":\" + self.port);\n\n    if (self.ssl) {\n      self.sock = tls.connect(self.port, self.host, self.ssl, connected);\n    } else {\n      self.sock = new net.Socket();\n      self.sock.connect(self.port, self.host, connected);\n    }\n\n    self.monitor = SMTPResponse.monitor(self.sock, self.timeout, function() {\n      self.close(true);\n    });\n    self.sock.once('response', response);\n    self.sock.once('error', response); // the socket could reset or throw, so let's handle it and let the user know\n  },\n\n  send: function(str, callback) {\n    var self = this;\n\n    if (self.sock && self._state == SMTPState.CONNECTED) {\n      log(str);\n\n      var response = function(err, msg) {\n        if (err) {\n          caller(callback, err);\n        } else {\n          log(msg.data);\n          caller(callback, null, msg);\n        }\n      };\n\n      self.sock.once('response', response);\n      self.sock.write(str);\n    } else {\n      self.close(true);\n      caller(callback, SMTPError('no connection has been established', SMTPError.NOCONNECTION));\n    }\n  },\n\n  command: function(cmd, callback, codes, failed) {\n    codes = Array.isArray(codes) ? codes : typeof(codes) == 'number' ? [codes] : [250];\n\n    var response = function(err, msg) {\n      if (err) {\n        caller(callback, err);\n      } else {\n        if (codes.indexOf(Number(msg.code)) != -1) {\n          caller(callback, err, msg.data, msg.message);\n        } else {\n          var errorMessage = \"bad response on command '\" + cmd.split(' ')[0] + \"'\";\n          if (msg.message) {\n            errorMessage += ': ' + msg.message;\n          }\n          caller(callback, SMTPError(errorMessage, SMTPError.BADRESPONSE, null, msg.data));\n        }\n      }\n    };\n\n    this.send(cmd + CRLF, response);\n  },\n\n  helo: function(callback, domain) {\n    /*\n     * SMTP 'helo' command.\n     * Hostname to send for self command defaults to the FQDN of the local\n     * host.\n     */\n\n    var self = this,\n\n      response = function(err, data) {\n        if (err) {\n          caller(callback, err);\n        } else {\n          self.parse_smtp_features(data);\n          caller(callback, err, data);\n        }\n      };\n\n    this.command(\"helo \" + (domain || this.domain), response);\n  },\n\n  starttls: function(callback) {\n    var self = this,\n\n      response = function(err, msg) {\n        if (err) {\n          err.message += \" while establishing a starttls session\";\n          caller(callback, err);\n        } else {\n          // support new API\n          if (tls.TLSSocket) {\n            var secured_socket = new tls.TLSSocket(self.sock, {\n              secureContext: tls.createSecureContext ? tls.createSecureContext(self.tls) : crypto.createCredentials(self.tls),\n              isServer: false // older versions of node (0.12), do not default to false properly...\n            });\n\n            secured_socket.on('error', function(err) {\n              self.close(true);\n              caller(callback, err);\n            });\n\n            self._secure = true;\n            self.sock = secured_socket;\n\n            SMTPResponse.monitor(self.sock, self.timeout, function() {\n              self.close(true);\n            });\n            caller(callback, msg.data);\n          } else {\n            var secured_socket = null;\n            var secured = function() {\n              self._secure = true;\n              self.sock = secured_socket;\n\n              var error = function(err) {\n                self.close(true);\n                caller(callback, err);\n              };\n\n              SMTPResponse.monitor(self.sock, self.timeout, function() {\n                self.close(true);\n              });\n              caller(callback, msg.data);\n            };\n\n            //secured_socket = starttls.secure(self.sock, self.tls, secured);\n            var starttls = require('starttls');\n            secured_socket = starttls({\n              socket: self.sock,\n              host: self.host,\n              port: self.port,\n              pair: tls.createSecurePair(\n                tls.createSecureContext ? tls.createSecureContext(self.tls) : crypto.createCredentials(self.tls), \n                false)\n            }, secured).cleartext;\n\n            secured_socket.on('error', function(err) {\n              self.close(true);\n              caller(callback, err);\n            });\n          }\n        }\n      };\n\n    this.command(\"starttls\", response, [220]);\n  },\n\n  parse_smtp_features: function(data) {\n    var self = this;\n\n    //  According to RFC1869 some (badly written)\n    //  MTA's will disconnect on an ehlo. Toss an exception if\n    //  that happens -ddm\n\n    data.split(\"\\n\").forEach(function(ext) {\n      var parse = ext.match(/^(?:\\d+[\\-=]?)\\s*?([^\\s]+)(?:\\s+(.*)\\s*?)?$/);\n\n      // To be able to communicate with as many SMTP servers as possible,\n      // we have to take the old-style auth advertisement into account,\n      // because:\n      // 1) Else our SMTP feature parser gets confused.\n      // 2) There are some servers that only advertise the auth methods we\n      // support using the old style.\n\n      if (parse) {\n        // RFC 1869 requires a space between ehlo keyword and parameters.\n        // It's actually stricter, in that only spaces are allowed between\n        // parameters, but were not going to check for that here.  Note\n        // that the space isn't present if there are no parameters.\n        self.features[parse[1].toLowerCase()] = parse[2] || true;\n      }\n    });\n\n    return;\n  },\n\n  ehlo: function(callback, domain) {\n    var self = this,\n\n      response = function(err, data) {\n        if (err) {\n          caller(callback, err);\n        } else {\n          self.parse_smtp_features(data);\n\n          if (self.tls && !self._secure) {\n            self.starttls(function() {\n              self.ehlo(callback, domain);\n            });\n          } else {\n            caller(callback, err, data);\n          }\n        }\n      };\n\n    this.features = {};\n    this.command(\"ehlo \" + (domain || this.domain), response);\n  },\n\n  has_extn: function(opt) {\n    return this.features[opt.toLowerCase()] === undefined;\n  },\n\n  help: function(callback, args) {\n    // SMTP 'help' command, returns text from the server\n    this.command(args ? \"help \" + args : \"help\", callback, [211, 214]);\n  },\n\n  rset: function(callback) {\n    this.command(\"rset\", callback);\n  },\n\n  noop: function(callback) {\n    this.send(\"noop\", callback);\n  },\n\n  mail: function(callback, from) {\n    this.command(\"mail FROM:\" + from, callback);\n  },\n\n  rcpt: function(callback, to) {\n    this.command(\"RCPT TO:\" + to, callback, [250, 251]);\n  },\n\n  data: function(callback) {\n    this.command(\"data\", callback, [354]);\n  },\n\n  data_end: function(callback) {\n    this.command(CRLF + \".\", callback);\n  },\n\n  message: function(data) {\n    log(data);\n    this.sock.write(data);\n  },\n\n  verify: function(address, callback) {\n    // SMTP 'verify' command -- checks for address validity.\"\"\"\n    this.command(\"vrfy \" + address, callback, [250, 251, 252]);\n  },\n\n  expn: function(address, callback) {\n    // SMTP 'expn' command -- expands a mailing list.\n    this.command(\"expn \" + address, callback);\n  },\n\n  ehlo_or_helo_if_needed: function(callback, domain) {\n    // Call self.ehlo() and/or self.helo() if needed.                                 \n    // If there has been no previous EHLO or HELO command self session, self\n    //  method tries ESMTP EHLO first.\n    var self = this;\n\n    if (!this.features) {\n      var response = function(err, data) {\n        caller(callback, err, data);\n      };\n\n      var attempt = function(err, data) {\n        if (err) self.helo(response, domain);\n        else caller(callback, err, data);\n      };\n\n      self.ehlo(attempt, domain);\n    }\n  },\n\n  login: function(callback, user, password, options) {\n    var self = this,\n\n      login = {\n        user: user ? function() {\n          return user;\n        } : self.user,\n        password: password ? function() {\n          return password;\n        } : self.password,\n        method: options && options.method ? options.method.toUpperCase() : ''\n      },\n\n      domain = options && options.domain ? options.domain : this.domain,\n\n      initiate = function(err, data) {\n        if (err) {\n          caller(callback, err);\n          return;\n        }\n\n        /* \n         * Log in on an SMTP server that requires authentication.\n         *\n         * The arguments are:\n         *     - user:     The user name to authenticate with.\n         *     - password: The password for the authentication.\n         *\n         * If there has been no previous EHLO or HELO command self session, self\n         * method tries ESMTP EHLO first.\n         *\n         * This method will return normally if the authentication was successful.\n         */\n\n        var method = null,\n\n          encode_cram_md5 = function(challenge) {\n            challenge = (new Buffer(challenge, \"base64\")).toString(\"ascii\");\n\n            var hmac = crypto.createHmac('md5', login.password());\n            hmac.update(challenge);\n\n            return (new Buffer(login.user() + \" \" + hmac.digest('hex')).toString(\"base64\"));\n          },\n\n          encode_plain = function() {\n            return (new Buffer(\"\\u0000\" + login.user() + \"\\u0000\" + login.password())).toString(\"base64\");\n          },\n\n          encode_xoauth2 = function() {\n            // console.log(\"user=\" + login.user() + \"\\1auth=Bearer \" + login.password()+\"\\1\\1\"); \n            // see: https://developers.google.com/gmail/xoauth2_protocol\n            return (new Buffer(\"user=\" + login.user() + \"\\u0001auth=Bearer \" + login.password() + \"\\u0001\\u0001\")).toString(\"base64\");\n          };\n\n        // List of authentication methods we support: from preferred to\n        // less preferred methods.\n        if (!method) {\n          var preferred = self.authentication;\n\n          for (var i = 0; i < preferred.length; i++) {\n            if ((self.features.auth || \"\").indexOf(preferred[i]) != -1) {\n              method = preferred[i];\n              break;\n            }\n          }\n        }\n\n        // handle bad responses from command differently\n        var failed = function(err, data) {\n          self.loggedin = false;\n          self.close(); // if auth is bad, close the connection, it won't get better by itself\n          caller(callback, SMTPError('authorization.failed', SMTPError.AUTHFAILED, err, data));\n        };\n\n        var response = function(err, data) {\n          if (err) {\n            failed(err, data);\n          } else {\n            self.loggedin = true;\n            caller(callback, err, data);\n          }\n        };\n\n        var attempt = function(err, data, msg) {\n          if (err) {\n            failed(err, data);\n          } else {\n            if (method == AUTH_METHODS.CRAM_MD5) {\n              self.command(encode_cram_md5(msg), response, [235, 503]);\n            } else if (method == AUTH_METHODS.LOGIN) {\n              self.command((new Buffer(login.password())).toString(\"base64\"), response, [235, 503]);\n            }\n          }\n        };\n\n        var attempt_user = function(err, data, msg) {\n          if (err) {\n            failed(err, data);\n          } else {\n            if (method == AUTH_METHODS.LOGIN) {\n              self.command((new Buffer(login.user())).toString(\"base64\"), attempt, [334]);\n            }\n          }\n        };\n\n        if (method == AUTH_METHODS.CRAM_MD5) self.command(\"AUTH \" + AUTH_METHODS.CRAM_MD5, attempt, [334]);\n\n        else if (method == AUTH_METHODS.LOGIN) self.command(\"AUTH \" + AUTH_METHODS.LOGIN, attempt_user, [334]);\n\n        else if (method == AUTH_METHODS.PLAIN) self.command(\"AUTH \" + AUTH_METHODS.PLAIN + \" \" + encode_plain(login.user(), login.password()), response, [235, 503]);\n\n        else if (method == AUTH_METHODS.XOAUTH2) self.command(\"AUTH \" + AUTH_METHODS.XOAUTH2 + \" \" + encode_xoauth2(login.user(), login.password()), response, [235, 503]);\n\n        else if (!method) caller(callback, SMTPError('no form of authorization supported', SMTPError.AUTHNOTSUPPORTED, null, data));\n      };\n\n    self.ehlo_or_helo_if_needed(initiate, domain);\n  },\n\n  close: function(force) {\n    if (this.sock) {\n      if (force) {\n        log(\"smtp connection destroyed!\");\n        this.sock.destroy();\n      } else {\n        log(\"smtp connection closed.\");\n        this.sock.end();\n      }\n    }\n\n    if (this.monitor) {\n      this.monitor.stop();\n      this.monitor = null;\n    }\n\n    this._state = SMTPState.NOTCONNECTED;\n    this._secure = false;\n    this.sock = null;\n    this.features = null;\n    this.loggedin = !(this.user() && this.password());\n  },\n\n  quit: function(callback) {\n    var self = this,\n      response = function(err, data) {\n        caller(callback, err, data);\n        self.close();\n      };\n\n    this.command(\"quit\", response, [221, 250]);\n  }\n};\n\nfor (var each in events.EventEmitter.prototype) {\n  SMTP.prototype[each] = events.EventEmitter.prototype[each];\n}\n\nexports.SMTP = SMTP;\nexports.state = SMTPState;\nexports.authentication = AUTH_METHODS;\n","/home/travis/build/npmtest/node-npmtest-emailjs/node_modules/emailjs/smtp/response.js":"var SMTPError = require('./error');\n\nvar SMTPResponse = function(stream, timeout, onerror) \n{\n  var buffer = '',\n\n  notify = function()\n  {\n    if(buffer.length)\n    {\n      // parse buffer for response codes\n      var line = buffer.replace(\"\\r\", '');\n        \n      if(!line.trim().split(/\\n/).pop().match(/^(\\d{3})\\s/))\n          return;\n        \n      var match = line ? line.match(/(\\d+)\\s?(.*)/) : null;\n\n      stream.emit('response', null, match ? {code:match[1], message:match[2], data:line} : {code:-1, data:line});\n      buffer = '';\n    }\n  },\n\n  error = function(err)\n  {\n    stream.emit('response', SMTPError('connection encountered an error', SMTPError.ERROR, err));\n  },\n\n  timedout = function(err)\n  {\n    stream.end();\n    stream.emit('response', SMTPError('timedout while connecting to smtp server', SMTPError.TIMEDOUT, err));\n  },\n\n  watch = function(data)\n  {\n    //var data = stream.read();\n    if (data !== null) {\n      var decoded = data.toString();\n      var emit\t\t= false;\n      var code\t\t= 0;\n\n      buffer += decoded;\n      notify();\n    }\n  },\n\n  close = function(err)\n  {\n    stream.emit('response', SMTPError('connection has closed', SMTPError.CONNECTIONCLOSED, err));\n  },\n\n  end = function(err)\n  {\n    stream.emit('response', SMTPError('connection has ended', SMTPError.CONNECTIONENDED, err));\n  };\n\n  this.stop = function(err) {\n    stream.removeAllListeners('response');\n    //stream.removeListener('readable', watch);\n    stream.removeListener('data', watch);\n    stream.removeListener('end', end);\n    stream.removeListener('close', close);\n    stream.removeListener('error', error);\n\n    if(err && typeof(onerror) == \"function\")\n      onerror(err);\n  };\n\n  //stream.on('readable', watch);\n  stream.on('data', watch);\n  stream.on('end', end);\n  stream.on('close', close);\n  stream.on('error', error);\n  stream.setTimeout(timeout, timedout);\n};\n\nexports.monitor = function(stream, timeout, onerror) \n{\n  return new SMTPResponse(stream, timeout, onerror);\n};\n","/home/travis/build/npmtest/node-npmtest-emailjs/node_modules/emailjs/smtp/error.js":"module.exports = function(message, code, error, smtp)\n{\n  var err = new Error(message);\n  err.code = code;\n  if(error)\n    err.previous = error;\n  err.smtp = smtp;\n\n  return err;\n};\n\nmodule.exports.COULDNOTCONNECT =\t1;\nmodule.exports.BADRESPONSE = 2;\nmodule.exports.AUTHFAILED = 3;\nmodule.exports.TIMEDOUT = 4;\nmodule.exports.ERROR = 5;\nmodule.exports.NOCONNECTION = 6;\nmodule.exports.AUTHNOTSUPPORTED = 7;\nmodule.exports.CONNECTIONCLOSED = 8;\nmodule.exports.CONNECTIONENDED = 9;\nmodule.exports.CONNECTIONAUTH = 10;\n","/home/travis/build/npmtest/node-npmtest-emailjs/node_modules/emailjs/smtp/message.js":"var stream     = require('stream');\nvar util       = require('util');\nvar fs         = require('fs');\nvar os         = require('os');\nvar path       = require('path');\nvar moment     = require('moment');\nvar mimelib    = require('mimelib');\nvar addressparser = require('addressparser');\nvar CRLF       = \"\\r\\n\";\nvar MIMECHUNK  = 76; // MIME standard wants 76 char chunks when sending out.\nvar BASE64CHUNK= 24; // BASE64 bits needed before padding is used\nvar MIME64CHUNK= MIMECHUNK * 6; // meets both base64 and mime divisibility\nvar BUFFERSIZE = MIMECHUNK*24*7; // size of the message stream buffer\nvar counter    = 0;\n\n// support for nodejs without Buffer.concat native function\nif(!Buffer.concat)\n{\n   require(\"bufferjs/concat\");\n}\n\nvar generate_boundary = function()\n{\n   var text       = \"\";\n   var possible    = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'()+_,-./:=?\";\n\n   for(var i=0; i < 69; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n   return text;\n};\n\nfunction person2address(l)\n{\n  var addresses = addressparser(l);\n  return addresses.map(function(addr) {\n    return addr.name ? mimelib.encodeMimeWord(addr.name, 'Q', 'utf-8').replace(/,/g, '=2C') + ' ' + '<' + addr.address + '>' : addr.address;\n  }).join(', ');\n}\n\nvar fix_header_name_case = function(header_name) {\n    return header_name.toLowerCase().replace(/^(.)|-(.)/g, function(match) {\n        return match.toUpperCase();\n    });\n};\n\nvar Message = function(headers)\n{\n   this.attachments  = [];\n   this.alternative  = null;\n   var now = new Date();\n   this.header       = {\n      \"message-id\":\"<\" + now.getTime() + \".\" + (counter++) + \".\" + process.pid + \"@\" + os.hostname() +\">\",\n      \"date\":moment().locale('en').format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\")\n   };\n   this.content      = \"text/plain; charset=utf-8\";\n\n   for(var header in headers)\n   {\n      // allow user to override default content-type to override charset or send a single non-text message\n      if(/^content-type$/i.test(header))\n      {\n         this.content = headers[header];\n      }\n      else if(header == 'text')\n      {\n         this.text = headers[header];\n      }\n      else if(header == \"attachment\" && typeof (headers[header]) == \"object\")\n      {\n         if(Array.isArray(headers[header])) {\n            var that = this;\n\n            for (var i = 0, l = headers[header].length; i < l; i++) {\n              this.attach(headers[header][i]);\n            }\n         } else {\n            this.attach(headers[header]);\n         }\n      }\n      else if(header == 'subject')\n      {\n         this.header.subject = mimelib.encodeMimeWord(headers.subject, 'Q', 'utf-8');\n      }\n      else if(/^(cc|bcc|to|from)/i.test(header))\n      {\n         this.header[header.toLowerCase()] = person2address(headers[header]);\n      }\n      else\n      {\n         // allow any headers the user wants to set??\n         // if(/cc|bcc|to|from|reply-to|sender|subject|date|message-id/i.test(header))\n         this.header[header.toLowerCase()] = headers[header];\n      }\n   }\n};\n\nMessage.prototype =\n{\n   attach: function(options)\n   {\n      /*\n         legacy support, will remove eventually...\n         arguments -> (path, type, name, headers)\n      */\n      if (arguments.length > 1)\n        options = {path:options, type:arguments[1], name:arguments[2]};\n\n      // sender can specify an attachment as an alternative\n      if(options.alternative)\n      {\n         this.alternative           = options;\n         this.alternative.charset   = options.charset || \"utf-8\";\n         this.alternative.type      = options.type || \"text/html\";\n         this.alternative.inline    = true;\n      }\n      else\n         this.attachments.push(options);\n\n      return this;\n   },\n\n   /*\n      legacy support, will remove eventually...\n      should use Message.attach() instead\n   */\n   attach_alternative: function(html, charset)\n   {\n      this.alternative =\n      {\n         data:    html,\n         charset: charset || \"utf-8\",\n         type:    \"text/html\",\n         inline:  true\n      };\n\n      return this;\n   },\n\n   valid: function(callback)\n   {\n      var self = this;\n\n      if(!self.header.from)\n      {\n         callback(false, \"message does not have a valid sender\");\n      }\n      if(!(self.header.to || self.header.cc || self.header.bcc))\n      {\n         callback(false, \"message does not have a valid recipient\");\n      }\n      else if(self.attachments.length === 0)\n      {\n         callback(true);\n      }\n      else\n      {\n         var check  = [];\n         var failed = [];\n\n         self.attachments.forEach(function(attachment, index)\n         {\n            if(attachment.path)\n            {\n               // migrating path->fs for existsSync)\n               if(!(fs.existsSync || path.existsSync)(attachment.path))\n                  failed.push(attachment.path + \" does not exist\");\n            }\n            else if(attachment.stream)\n            {\n               if(!attachment.stream.readable)\n                  failed.push(\"attachment stream is not readable\");\n            }\n            else if(!attachment.data)\n            {\n               failed.push(\"attachment has no data associated with it\");\n            }\n         });\n\n         callback(failed.length === 0, failed.join(\", \"));\n      }\n   },\n\n   stream: function()\n   {\n      return new MessageStream(this);\n   },\n\n   read: function(callback)\n   {\n      var buffer = \"\";\n\n      var capture = function(data)\n      {\n         buffer += data;\n      };\n\n      var output = function(err)\n      {\n         callback(err, buffer);\n      };\n\n      var str = this.stream();\n\n      str.on('data', capture);\n      str.on('end', output);\n      str.on('error', output);\n   }\n};\n\nvar MessageStream = function(message)\n{\n   var self       = this;\n\n   stream.Stream.call(self);\n\n   self.message   = message;\n   self.readable  = true;\n   self.paused    = false;\n   self.buffer    = new Buffer(MIMECHUNK*24*7);\n   self.bufferIndex = 0;\n\n   var output_process = function(next, args)\n   {\n      if(self.paused)\n      {\n         self.resumed = function() { next.apply(null, args); };\n      }\n      else\n      {\n         next.apply(null, args);\n      }\n\n      next.apply(null, args);\n   };\n\n   var output_mixed = function()\n   {\n      var boundary   = generate_boundary();\n      var data       = [\"Content-Type: multipart/mixed; boundary=\\\"\", boundary, \"\\\"\", CRLF, CRLF, \"--\", boundary, CRLF];\n\n      output(data.join(''));\n\n      if(!self.message.alternative)\n      {\n         output_text(self.message);\n         output_message(boundary, self.message.attachments, 0, close);\n      }\n      else\n      {\n         output_alternative(self.message, function() { output_message(boundary, self.message.attachments, 0, close); });\n      }\n   };\n\n   var output_message = function(boundary, list, index, callback)\n   {\n      if(index < list.length)\n      {\n         output([\"--\", boundary, CRLF].join(''));\n\n         if(list[index].related)\n         {\n            output_related(list[index], function() { output_message(boundary, list, index + 1, callback); });\n         }\n         else\n         {\n            output_attachment(list[index], function() { output_message(boundary, list, index + 1, callback); });\n         }\n      }\n      else\n      {\n         output([CRLF, \"--\", boundary, \"--\", CRLF, CRLF].join(''));\n         callback();\n      }\n   };\n\n   var output_attachment_headers = function(attachment)\n   {\n      var data = [],\n          header,\n          headers =\n          {\n            'content-type': attachment.type +\n              (attachment.charset ? \"; charset=\" + attachment.charset : \"\") +\n              (attachment.method ? \"; method=\" + attachment.method : \"\"),\n            'content-transfer-encoding': 'base64',\n            'content-disposition': attachment.inline ? 'inline' : 'attachment; filename=\"' + mimelib.encodeMimeWord(attachment.name, 'Q', 'utf-8') + '\"'\n          };\n\n      for(header in (attachment.headers || {}))\n      {\n         // allow sender to override default headers\n         headers[header.toLowerCase()] = attachment.headers[header];\n      }\n\n      for(header in headers)\n      {\n         data = data.concat([fix_header_name_case(header), ': ', headers[header], CRLF]);\n      }\n\n      output(data.concat([CRLF]).join(''));\n   };\n\n   var output_attachment = function(attachment, callback)\n   {\n      var build = attachment.path ? output_file : attachment.stream ? output_stream : output_data;\n      output_attachment_headers(attachment);\n      build(attachment, callback);\n   };\n\n   var output_data = function(attachment, callback)\n   {\n      output_base64(attachment.encoded ? attachment.data : new Buffer(attachment.data).toString(\"base64\"), callback);\n   };\n\n   var output_file = function(attachment, next)\n   {\n      var chunk      = MIME64CHUNK*16;\n      var buffer     = new Buffer(chunk);\n      var closed     = function(fd) { fs.close(fd); };\n      var opened     = function(err, fd)\n      {\n         if(!err)\n         {\n            var read = function(err, bytes)\n            {\n               if(!err && self.readable)\n               {\n                  // guaranteed to be encoded without padding unless it is our last read\n                  output_base64(buffer.toString(\"base64\", 0, bytes), function()\n                  {\n                     if(bytes == chunk) // we read a full chunk, there might be more\n                     {\n                        fs.read(fd, buffer, 0, chunk, null, read);\n                     }\n                     else // that was the last chunk, we are done reading the file\n                     {\n                        self.removeListener(\"error\", closed);\n                        fs.close(fd, next);\n                     }\n                  });\n               }\n               else\n               {\n                  self.emit('error', err || {message:\"message stream was interrupted somehow!\"});\n               }\n            };\n\n            fs.read(fd, buffer, 0, chunk, null, read);\n            self.once(\"error\", closed);\n         }\n         else\n            self.emit('error', err);\n      };\n\n      fs.open(attachment.path, 'r', opened);\n   };\n\n   var output_stream = function(attachment, callback)\n   {\n      if(attachment.stream.readable)\n      {\n         var previous = null;\n\n         attachment.stream.resume();\n         attachment.stream.on('end', function()\n         {\n            output_base64((previous || new Buffer(0)).toString(\"base64\"), callback);\n            self.removeListener('pause', attachment.stream.pause);\n            self.removeListener('resume', attachment.stream.resume);\n            self.removeListener('error', attachment.stream.resume);\n         });\n\n         attachment.stream.on('data', function(buffer)\n         {\n            // do we have bytes from a previous stream data event?\n            if(previous)\n            {\n               var buffer2 = Buffer.concat([previous, buffer]);\n               previous    = null; // free up the buffer\n               buffer      = null; // free up the buffer\n               buffer      = buffer2;\n            }\n\n            var padded = buffer.length % (MIME64CHUNK);\n\n            // encode as much of the buffer to base64 without empty bytes\n            if(padded)\n            {\n               previous = new Buffer(padded);\n               // copy dangling bytes into previous buffer\n               buffer.copy(previous, 0, buffer.length - padded);\n            }\n\n            output_base64(buffer.toString(\"base64\", 0, buffer.length - padded));\n         });\n\n         self.on('pause', attachment.stream.pause);\n         self.on('resume', attachment.stream.resume);\n         self.on('error', attachment.stream.resume);\n      }\n      else\n         self.emit('error', {message:\"stream not readable\"});\n   };\n\n   var output_base64 = function(data, callback)\n   {\n      var loops   = Math.ceil(data.length / MIMECHUNK);\n      var loop    = 0;\n\n      while(loop < loops)\n      {\n        output(data.substring(MIMECHUNK * loop, MIMECHUNK * (loop + 1)) + CRLF);\n        loop++;\n      }\n\n      if(callback)\n        callback();\n   };\n\n   var output_text = function(message)\n   {\n      var data = [];\n\n      data = data.concat([\"Content-Type:\", message.content, CRLF, \"Content-Transfer-Encoding: 7bit\", CRLF]);\n      data = data.concat([\"Content-Disposition: inline\", CRLF, CRLF]);\n      data = data.concat([message.text || \"\", CRLF, CRLF]);\n\n      output(data.join(''));\n   };\n\n   var output_alternative = function(message, callback)\n   {\n      var data = [], boundary = generate_boundary();\n\n      data     = data.concat([\"Content-Type: multipart/alternative; boundary=\\\"\", boundary, \"\\\"\", CRLF, CRLF]);\n      data     = data.concat([\"--\", boundary, CRLF]);\n\n      output(data.join(''));\n      output_text(message);\n      output([\"--\", boundary, CRLF].join(''));\n\n      var finish = function()\n      {\n         output([CRLF, \"--\", boundary, \"--\", CRLF, CRLF].join(''));\n         callback();\n      };\n\n      if(message.alternative.related)\n      {\n         output_related(message.alternative, finish);\n      }\n      else\n      {\n         output_attachment(message.alternative, finish);\n      }\n   };\n\n   var output_related = function(message, callback)\n   {\n      var data = [], boundary = generate_boundary();\n\n      data     = data.concat([\"Content-Type: multipart/related; boundary=\\\"\", boundary, \"\\\"\", CRLF, CRLF]);\n      data     = data.concat([\"--\", boundary, CRLF]);\n\n      output(data.join(''));\n\n      output_attachment(message, function()\n      {\n         output_message(boundary, message.related, 0, function()\n         {\n            output([CRLF, \"--\", boundary, \"--\", CRLF, CRLF].join(''));\n            callback();\n         });\n      });\n   };\n\n   var output_header_data = function()\n   {\n      if(self.message.attachments.length || self.message.alternative)\n      {\n         output(\"MIME-Version: 1.0\" + CRLF);\n         output_mixed();\n      }\n      else // you only have a text message!\n      {\n         output_text(self.message);\n         close();\n      }\n   };\n\n   var output_header = function()\n   {\n      var data = [];\n\n      for(var header in self.message.header)\n      {\n         // do not output BCC in the headers (regex) nor custom Object.prototype functions...\n         if(!(/bcc/i.test(header)) && self.message.header.hasOwnProperty (header))\n            data = data.concat([fix_header_name_case(header), \": \", self.message.header[header], CRLF]);\n      }\n\n      output(data.join(''));\n      output_header_data();\n   };\n\n   var output = function(data, callback, args)\n   {\n      var bytes = Buffer.byteLength(data);\n\n      // can we buffer the data?\n      if(bytes + self.bufferIndex < self.buffer.length)\n      {\n         self.buffer.write(data, self.bufferIndex);\n         self.bufferIndex += bytes;\n\n         if(callback)\n            callback.apply(null, args);\n      }\n      // we can't buffer the data, so ship it out!\n      else if(bytes > self.buffer.length)\n      {\n         if(self.bufferIndex)\n         {\n            self.emit('data', self.buffer.toString(\"utf-8\", 0, self.bufferIndex));\n            self.bufferIndex = 0;\n         }\n\n         var loops   = Math.ceil(data.length / self.buffer.length);\n         var loop    = 0;\n\n         while(loop < loops)\n         {\n           self.emit('data', data.substring(self.buffer.length*loop, self.buffer.length*(loop + 1)));\n           loop++;\n         }\n      }\n      else // we need to clean out the buffer, it is getting full\n      {\n         if(!self.paused)\n         {\n            self.emit('data', self.buffer.toString(\"utf-8\", 0, self.bufferIndex));\n            self.buffer.write(data, 0);\n            self.bufferIndex = bytes;\n\n            // we could get paused after emitting data...\n            if(self.paused)\n            {\n               self.once(\"resume\", function() { callback.apply(null, args); });\n            }\n            else if(callback)\n            {\n               callback.apply(null, args);\n            }\n         }\n         else // we can't empty out the buffer, so let's wait till we resume before adding to it\n         {\n            self.once(\"resume\", function() { output(data, callback, args); });\n         }\n      }\n   };\n\n   var close = function(err)\n   {\n      if(err)\n      {\n         self.emit(\"error\", err);\n      }\n      else\n      {\n         self.emit('data', self.buffer.toString(\"utf-8\", 0, self.bufferIndex));\n         self.emit('end');\n      }\n\n      self.buffer = null;\n      self.bufferIndex = 0;\n      self.readable = false;\n      self.removeAllListeners(\"resume\");\n      self.removeAllListeners(\"pause\");\n      self.removeAllListeners(\"error\");\n      self.removeAllListeners(\"data\");\n      self.removeAllListeners(\"end\");\n   };\n\n   self.once(\"destroy\", close);\n   process.nextTick(output_header);\n};\n\nutil.inherits(MessageStream, stream.Stream);\n\nMessageStream.prototype.pause = function()\n{\n   this.paused = true;\n   this.emit('pause');\n};\n\nMessageStream.prototype.resume = function()\n{\n   this.paused = false;\n   this.emit('resume');\n};\n\nMessageStream.prototype.destroy = function()\n{\n   this.emit(\"destroy\", self.bufferIndex > 0 ? {message:\"message stream destroyed\"} : null);\n};\n\nMessageStream.prototype.destroySoon = function()\n{\n   this.emit(\"destroy\");\n};\n\nexports.Message = Message;\nexports.BUFFERSIZE = BUFFERSIZE;\nexports.create = function(headers)\n{\n   return new Message(headers);\n};\n"}